package geo

import (
	"context"
	"encoding/json"
	"fmt"
	"math"
	"time"

	"github.com/google/uuid"
	"github.com/richxcame/ride-hailing/pkg/common"
	redisClient "github.com/richxcame/ride-hailing/pkg/redis"
)

const (
	driverLocationPrefix = "driver:location:"
	driverLocationTTL    = 5 * time.Minute
	driverGeoIndexKey    = "drivers:geo:index" // Redis GEO key for all active drivers
	driverStatusPrefix   = "driver:status:"
	searchRadiusKm       = 10.0 // Search radius in kilometers
)

// DriverLocation represents a driver's location
type DriverLocation struct {
	DriverID  uuid.UUID `json:"driver_id"`
	Latitude  float64   `json:"latitude"`
	Longitude float64   `json:"longitude"`
	Timestamp time.Time `json:"timestamp"`
}

// Service handles geolocation business logic
type Service struct {
	redis *redisClient.Client
}

// NewService creates a new geo service
func NewService(redis *redisClient.Client) *Service {
	return &Service{redis: redis}
}

// UpdateDriverLocation updates a driver's current location
func (s *Service) UpdateDriverLocation(ctx context.Context, driverID uuid.UUID, latitude, longitude float64) error {
	location := &DriverLocation{
		DriverID:  driverID,
		Latitude:  latitude,
		Longitude: longitude,
		Timestamp: time.Now(),
	}

	data, err := json.Marshal(location)
	if err != nil {
		return common.NewInternalServerError("failed to marshal location data")
	}

	// Store detailed location data
	key := fmt.Sprintf("%s%s", driverLocationPrefix, driverID.String())
	if err := s.redis.SetWithExpiration(ctx, key, data, driverLocationTTL); err != nil {
		return common.NewInternalServerError("failed to update driver location")
	}

	// Add to Redis GeoSpatial index for efficient nearby search
	if err := s.redis.GeoAdd(ctx, driverGeoIndexKey, longitude, latitude, driverID.String()); err != nil {
		return common.NewInternalServerError("failed to add driver to geo index")
	}

	return nil
}

// GetDriverLocation retrieves a driver's current location
func (s *Service) GetDriverLocation(ctx context.Context, driverID uuid.UUID) (*DriverLocation, error) {
	key := fmt.Sprintf("%s%s", driverLocationPrefix, driverID.String())
	data, err := s.redis.GetString(ctx, key)
	if err != nil {
		return nil, common.NewNotFoundError("driver location not found")
	}

	var location DriverLocation
	if err := json.Unmarshal([]byte(data), &location); err != nil {
		return nil, common.NewInternalServerError("failed to unmarshal location data")
	}

	return &location, nil
}

// FindNearbyDrivers finds drivers near a given location using Redis GeoSpatial
func (s *Service) FindNearbyDrivers(ctx context.Context, latitude, longitude float64, maxDrivers int) ([]*DriverLocation, error) {
	// Use Redis GEORADIUS to find nearby drivers
	driverIDs, err := s.redis.GeoRadius(ctx, driverGeoIndexKey, longitude, latitude, searchRadiusKm, maxDrivers)
	if err != nil {
		return nil, common.NewInternalErrorWithError("failed to search nearby drivers", err)
	}

	if len(driverIDs) == 0 {
		return []*DriverLocation{}, nil
	}

	// Get detailed location data for each driver
	var locations []*DriverLocation
	for _, driverIDStr := range driverIDs {
		driverID, err := uuid.Parse(driverIDStr)
		if err != nil {
			continue // Skip invalid UUIDs
		}

		location, err := s.GetDriverLocation(ctx, driverID)
		if err != nil {
			continue // Skip drivers without location data
		}

		// Calculate distance from pickup point
		distance := s.CalculateDistance(latitude, longitude, location.Latitude, location.Longitude)

		// Only include drivers within search radius
		if distance <= searchRadiusKm {
			locations = append(locations, location)
		}
	}

	return locations, nil
}

// SetDriverStatus sets driver's availability status
func (s *Service) SetDriverStatus(ctx context.Context, driverID uuid.UUID, status string) error {
	key := fmt.Sprintf("%s%s", driverStatusPrefix, driverID.String())
	data := map[string]interface{}{
		"status":    status,
		"timestamp": time.Now(),
	}

	jsonData, err := json.Marshal(data)
	if err != nil {
		return common.NewInternalErrorWithError("failed to marshal status", err)
	}

	if err := s.redis.SetWithExpiration(ctx, key, jsonData, driverLocationTTL); err != nil {
		return common.NewInternalErrorWithError("failed to set driver status", err)
	}

	// If driver goes offline, remove from geo index
	if status == "offline" {
		s.redis.GeoRemove(ctx, driverGeoIndexKey, driverID.String())
	}

	return nil
}

// GetDriverStatus gets driver's availability status
func (s *Service) GetDriverStatus(ctx context.Context, driverID uuid.UUID) (string, error) {
	key := fmt.Sprintf("%s%s", driverStatusPrefix, driverID.String())
	data, err := s.redis.GetString(ctx, key)
	if err != nil {
		return "offline", nil // Default to offline if not found
	}

	var statusData map[string]interface{}
	if err := json.Unmarshal([]byte(data), &statusData); err != nil {
		return "offline", nil
	}

	if status, ok := statusData["status"].(string); ok {
		return status, nil
	}

	return "offline", nil
}

// FindAvailableDrivers finds nearby available drivers (not busy with a ride)
func (s *Service) FindAvailableDrivers(ctx context.Context, latitude, longitude float64, maxDrivers int) ([]*DriverLocation, error) {
	// First, find nearby drivers using geospatial search
	nearbyDrivers, err := s.FindNearbyDrivers(ctx, latitude, longitude, maxDrivers*2) // Get more to filter
	if err != nil {
		return nil, err
	}

	// Filter for available drivers
	var availableDrivers []*DriverLocation
	for _, driver := range nearbyDrivers {
		status, err := s.GetDriverStatus(ctx, driver.DriverID)
		if err != nil || status != "available" {
			continue
		}

		availableDrivers = append(availableDrivers, driver)
		if len(availableDrivers) >= maxDrivers {
			break
		}
	}

	return availableDrivers, nil
}

// CalculateDistance calculates distance between two coordinates in kilometers
func (s *Service) CalculateDistance(lat1, lon1, lat2, lon2 float64) float64 {
	const earthRadius = 6371.0 // km

	dLat := (lat2 - lat1) * math.Pi / 180.0
	dLon := (lon2 - lon1) * math.Pi / 180.0

	a := math.Sin(dLat/2)*math.Sin(dLat/2) +
		math.Cos(lat1*math.Pi/180.0)*math.Cos(lat2*math.Pi/180.0)*
			math.Sin(dLon/2)*math.Sin(dLon/2)

	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	distance := earthRadius * c

	return math.Round(distance*100) / 100
}

// CalculateETA calculates estimated time of arrival in minutes
func (s *Service) CalculateETA(distance float64) int {
	const averageSpeed = 40.0 // km/h in city traffic
	eta := (distance / averageSpeed) * 60
	return int(math.Round(eta))
}
